Tracing JIT with Profile Guided AOT Setting
=========================================================

This Python based implementation supports the optimization based on the profiling file: <br />
As you can see from the tests folder, the example named "branch.bril" is the test source code. And the file named "branch_profile.json" is the profiling file which contains the branch instruction and the cooresponding first instructions of the branch destination block. <br/>
The example named "branch.bril" is manually written code, whereas the "branch_profile.json" is generated by a modified brili interpreter. <br/>


## Run the code
```javascript
  // without tracing based JIT optimization
  $ bril2json < tests/branch.bril | brili -p 3
  // with tracing based JIT optimization
  $ bril2json < tests/branch.bril | python tracing_JIT.py | brili -p 3
  // with tracing based JIT optimization and DCE optimization
  $ bril2json < tests/branch.bril | python tracing_JIT.py | brili -p 3
```

## Sample Outputs
```javascript
  // without tracing based JIT optimization
  $ bril2json < tests/branch.bril | brili -p 3

  total_dyn_inst: 10

  // with tracing based JIT optimization
  $ bril2json < tests/branch.bril | python tracing_JIT.py | brili -p 3
  
  total_dyn_inst: 12

  // with tracing based JIT optimization and DCE optimization
  $ bril2json < tests/branch.bril | python tracing_JIT.py | brili -p 3

  total_dyn_inst: 10
```

We evaluate the optimization by leveraging the total number of dynamic instruction count offered by the "-p" flag. For this example, without JIT optimication ,the total cycle count for the input "3" is 10. Then with the JIT optimization, the total cycle count is even larger, i.e., 12. The reason is that we are adding three more instructions (speculate, guard, and commit) in the path and only delete one branch instruction. Thus the total cycle count is 12. <br/>
But if we apply other optimizations, like the DCE optimizaion from previous task, the dead code are eliminated by speculating the branch path. Thus, the total cycle count for the third experiment is 10. As for more complicated examples, this profiling based JIT optimization will save more cycles combined with other optimizing techniques like LVN, LICM, etc. <br/>
